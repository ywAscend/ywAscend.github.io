<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>webpack-css抽离为单独文件</title>
    <url>/2020/05/13/css%E6%8A%BD%E7%A6%BB%E4%B8%BA%E5%8D%95%E7%8B%AC%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>基础配置中的css是通过style-loader 转为js的样式文件，最后插入在head中引入样式。这样的好处是，页面加载时不会重新请求css文件，但也有缺点页面一次性加载内容较多，影响加载速度。</p><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            test:/\.css$/,</span><br><span class="line">            use:[</span><br><span class="line">                &apos;style-loader&apos;, //创建style标签，将样式放入head中</span><br><span class="line">                &apos;css-loader&apos;</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = config</span><br></pre></td></tr></table></figure>
<p>运行效果：<br><img src="https://i.loli.net/2020/05/13/Wj9ZpilE8mVx2sF.png" alt="css-style.png"></p>
<p>通过 mini-css-extract-plugin 插件，将打包后的css通过link引入<br>好处：页面不会闪白 弊端：会发生link请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//安装插件 </span><br><span class="line">cnpm i mini-css-extract-plugin</span><br><span class="line">//引入插件</span><br><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;)</span><br><span class="line">// 配置</span><br><span class="line">const config = &#123;</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            // &apos;style-loader&apos; ,</span><br><span class="line">            MiniCssExtractPluign.loader, //这个loader取代style-loader。作用：提取js中的css成单独文件</span><br><span class="line">            &apos;css-loader&apos;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            //对输出文件进行重命名</span><br><span class="line">            filename: &apos;css/built.css&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<!-- ![css-link.png](https://i.loli.net/2020/05/13/hUBflnIqzFcP4Yb.png) -->

<p><img src="/images/css-link.png" alt></p>
<p>完整配置 webpack.config.js：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//引入路径</span><br><span class="line">const Path = require(&apos;path&apos;)</span><br><span class="line">//引入 html-webpack-pluign插件，作用将webpack打包后的js自动注入到html中</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">//引入mini-css-extract-plugin 插件，作用抽取css为单独文件</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry:&apos;./src/js/index.js&apos;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename: &apos;buit.js&apos;,</span><br><span class="line">        path: Path.reslove(__dirname,&apos;build&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            //样式loader</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use:[</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    &apos;css-loader&apos;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.less$/,</span><br><span class="line">                use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]</span><br><span class="line">            &#125;,</span><br><span class="line">            //图片loader</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.(jpg|png|gif)$/,</span><br><span class="line">                loader: &apos;url-loader&apos;,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    limit: 8*1024, </span><br><span class="line">                    esModule:false,</span><br><span class="line">                    name: &apos;[name].[hash:10].[ext]&apos;,</span><br><span class="line">                    outPath:&apos;img&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.html$/,</span><br><span class="line">                loader: &apos;html-loader&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                //处理字体图标</span><br><span class="line">                test:/\.(woff2|eot|ttf|woff|svg)$/,</span><br><span class="line">                loader: &apos;file-loader&apos;,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    outputPath:&apos;media&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./src/index.html&apos;</span><br><span class="line">        &#125;),</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            //对输出文件进行重命名</span><br><span class="line">            filename: &apos;css/built.css&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        contentBase: Path.reslove(__dirname,&apos;build&apos;),</span><br><span class="line">        compress: true,</span><br><span class="line">        port: 3000,</span><br><span class="line">        open: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack基本配置</title>
    <url>/2020/05/13/webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>webpack基本配置</p><a id="more"></a>
<ol>
<li>入口</li>
</ol>
<p>一、单个入口文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: &apos;./src/index.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单个入口文件简写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二、对象语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &apos;./src/index.js&apos;,</span><br><span class="line">        vendors: &apos;./src/vendors.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见应用场景：</p>
<p>分离应用程序和第三方库入口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js&apos;,</span><br><span class="line">    vendors: &apos;./src/vendors.js&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>webpack 从 app.js 和 vendors.js 开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的（每个 bundle 中都有一个 webpack 引导(bootstrap)）。这种方式比较常见于，只有一个入口起点（不包括 vendor）的单页应用程序(single page application)中。</p>
<p>此设置允许你使用 CommonsChunkPlugin 从「应用程序 bundle」中提取 vendor 引用(vendor reference) 到 vendor bundle，并把引用 vendor 的部分替换为 <strong>webpack_require</strong>() 调用。如果应用程序 bundle 中没有 vendor 代码，那么你可以在 webpack 中实现被称为长效缓存的通用模式。</p>
<p>多页面应用程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">entry: &#123;</span><br><span class="line">    pageOne: &apos;./src/pageOne/index.js&apos;,</span><br><span class="line">    pageTwo: &apos;./src/pageTwo/index.js&apos;,</span><br><span class="line">    pageThree: &apos;./src/pageThree/index.js&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例告诉 webpack 需要 3 个独立分离的依赖图.<br>在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事：<br>使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。</p>
<ol start="2">
<li>出口  </li>
</ol>
<p>配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置.</p>
<p>output 的值需要设置为一个对象，包含以下两点：</p>
<p>filename 用于输出文件的文件名。</p>
<p>目标输出目录 path 的绝对路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;built.js&apos;,</span><br><span class="line">        path: path.reslove(__dirname,&apos;build&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个入口起点</p>
<p>如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &apos;./src/app.js&apos;,</span><br><span class="line">        search: &apos;./src/search.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].js&apos;,</span><br><span class="line">        path: __dirname + &apos;/dist&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写入到硬盘：./dist/app.js, ./dist/search.js</span><br></pre></td></tr></table></figure>

<p>使用CDN加速(官方示例，没太懂)</p>
<p>config.js </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: &quot;/home/proj/cdn/assets/[hash]&quot;,</span><br><span class="line">    publicPath: &quot;http://cdn.example.com/assets/[hash]/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 <strong>webpack_public_path</strong>。</p>
<ol start="3">
<li>loader</li>
</ol>
<h4 id="处理样式-css-less-sass"><a href="#处理样式-css-less-sass" class="headerlink" title="处理样式 css/less/sass"></a>处理样式 css/less/sass</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use:[&apos;style-loader&apos;,&apos;css-loader&apos;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.les$/,</span><br><span class="line">                use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(sass|scss)$/,</span><br><span class="line">                use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = config</span><br></pre></td></tr></table></figure>

<h4 id="处理图片-jpg-png-gif-jpeg"><a href="#处理图片-jpg-png-gif-jpeg" class="headerlink" title="处理图片 jpg|png|gif|jpeg"></a>处理图片 jpg|png|gif|jpeg</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(jpg|png|gif|jpeg)$/,</span><br><span class="line">                loader: &apos;url-loader&apos;,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    limit: 8*1024, //小于8*1024的会被转为base64地址</span><br><span class="line">                    name: &apos;[name].[hash:10].[ext]&apos;, //name属性指向原来的名称，[hash:8]：取前10位hash值，总共32位</span><br><span class="line">                    esModule: false, //关闭es6模块,使用commonjs模块</span><br><span class="line">                    outputPath: &apos;imgs&apos; //打包后图片资源的输出目录</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                //html中的图片资源</span><br><span class="line">                test: /\.html$/,</span><br><span class="line">                loader:&apos;html-loader&apos;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    outputPath:&apos;imgs&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = config</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>plugins</li>
</ol>
<h4 id="使用html-webpack-plugin"><a href="#使用html-webpack-plugin" class="headerlink" title="使用html-webpack-plugin"></a>使用html-webpack-plugin</h4><p>将打包好的js文件自动注入到 html中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//安装</span><br><span class="line">cnpm i html-webpack-plugin -D</span><br><span class="line"></span><br><span class="line">//引用</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./src/index.html&apos;  //指定html模板</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>mode</li>
</ol>
<p>配置中提供 mode 选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;production&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者从 CLI 参数中传递：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack --mode=production</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>devServer  配置本地服务器</li>
</ol>
<p>Webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js构建，它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖：<br>安装插件 webpack-dev-server ： cnpm i webpack-dev-server -D</p>
<p>devServer作为webpack配置选项中的一项，以下是它的一些配置选项:</p>
<p>contentBase ：设置服务器所读取文件的目录，当前我们设置为”./build”<br>port ：设置端口号，如果省略，默认为8080<br>inline ：设置为true，当源文件改变时会自动刷新页面<br>historyApiFallback ：设置为true，所有的跳转将指向index.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        contentBase: &apos;./bulid&apos;, //服务器运行目录，默认webpack-dev-server会为根文件夹提供本地服务器，</span><br><span class="line">        compress: true, //启用gzip压缩</span><br><span class="line">        port: 3000,  //端口</span><br><span class="line">        open: true   //第一次运行时，自动打开浏览器</span><br><span class="line">        //inline: true , //设置为true,源文件改变时自动刷新页面</span><br><span class="line">        //historyApiFallback: true,  //设置为true，historyFallback能将所有没有做映射的地址都映射到一个入口：index.html中去。</span><br><span class="line">        //hot: true   //热加载，功能：只渲染所改组件的页面效果，不会全部刷新，其他页面数据依然会存在。使用hot,需要配置 hotModule相关模块</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        //热加载相关</span><br><span class="line">        new webpack.NameModulesPlugin(),</span><br><span class="line">        new webpack.HotModuleReplacementPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7 .source Map配置   <a href="https://segmentfault.com/a/1190000008315937" target="_blank" rel="noopener">具体配置详见</a></p>
<p>为方便调试打包后的文件，定位问题，通过配置source map 在打包时生成.map文件，使得打包后的代码可读性更高，更易于调试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry:&apos;./src/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;built.js&apos;,</span><br><span class="line">        path:path.reslove(__dirname,&apos;build&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &apos;source-map&apos; // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基础配置汇总"><a href="#基础配置汇总" class="headerlink" title="基础配置汇总"></a>基础配置汇总</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//引入path</span><br><span class="line">const Path = require(&apos;path&apos;)</span><br><span class="line">//引入 html-webpack-plugin</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/js/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;built.js&apos;,</span><br><span class="line">        path: Path.resolve(__dirname,&apos;build&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    //loader</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            //样式资源</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use:[&apos;style-loader&apos;,&apos;css-loader&apos;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]</span><br><span class="line">            &#125;,</span><br><span class="line">            //图片资源</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(jpg|png|gif)$/,</span><br><span class="line">                loader: &apos;url-loader&apos;,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    limit: 8*1024,</span><br><span class="line">                    esModule:false,</span><br><span class="line">                    name:&apos;[name].[hash:10].[ext]&apos;,</span><br><span class="line">                    outputPath: &apos;imgs&apos;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;  //html图片资源</span><br><span class="line">                test: /\.html$/,</span><br><span class="line">                loader: &apos;html-loader&apos;,</span><br><span class="line">            &#125;,</span><br><span class="line">            //其他资源，字体图标</span><br><span class="line">            &#123;</span><br><span class="line">                //exclude:/\.(js|html|css|jpg|png|gif|less)$/,</span><br><span class="line">                test:/\.(woff2|eot|ttf|woff|svg)$/,</span><br><span class="line">                loader: &apos;file-loader&apos;,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    outputPath:&apos;media&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template:&apos;./src/index.html&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        contentBase: &apos;./build&apos;,</span><br><span class="line">        compress: true,</span><br><span class="line">        port: 3000,</span><br><span class="line">        open: true</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &apos;source-map&apos;  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack介绍</title>
    <url>/2020/05/13/webpack/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>webpack四个核心概念</p><a id="more"></a>
<ol>
<li><p>入口：entry</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack入口，指示webpack应该使用哪个模块，来作为构建内部依赖图的开始。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>出口：output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack打包完成后，输出包。包含包名（filename）、输出包的位置(path)。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">    const path = require(&apos;path&apos;)</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">        entry: &apos;./src/index&apos;,</span><br><span class="line">        output:&#123;</span><br><span class="line">            filename: &apos;built.js&apos;,  //输出包名为 built.js</span><br><span class="line">            path:path.resolve(__dirname,&apos;build&apos;)  //输出包的位置为当前目录下的 build 文件夹下</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>loader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由于webpack自身只能处理js，但实际项目中会依赖以来很多非js类型的文件。而loader提供了webpack处理那些非js文件的能力。</span><br><span class="line">loader可以将所有类型的文件转为webpack能够处理的有效模块。然后再通过webpack的打包能力，进行处理打包。</span><br><span class="line">本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图可以直接引用的模块。</span><br><span class="line"></span><br><span class="line">loader中通常由两个属性 test、use</span><br><span class="line"></span><br><span class="line">-1) test 属性，用于标识要转换的文件类型</span><br><span class="line">-2）use 属性，表示进行转换时，要使用的loader</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">    const path = require(&apos;path&apos;)</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">        entry: &apos;./src/index.js&apos;,</span><br><span class="line">        output: &#123;</span><br><span class="line">            filename: &apos;built.js&apos;,</span><br><span class="line">            path: path.resolve(__dirname,&apos;build&apos;)</span><br><span class="line">        &#125;,</span><br><span class="line">        module: &#123;  //loader模块</span><br><span class="line">            rules: [  </span><br><span class="line">                &#123;   //css-loader</span><br><span class="line">                    test: /\.css$/,  </span><br><span class="line">                    use:[&apos;style-loader&apos;,&apos;css-loader&apos;]</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插件 plugins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loader 被用于转换某些类型的模块，而插件可以用于执行范围更广的任务。是对loader能力的扩充。</span><br><span class="line">插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能及其强大，可以用</span><br><span class="line">处理各种各样的任务。</span><br><span class="line"></span><br><span class="line">插件的使用步骤：</span><br><span class="line">安装插件 --&gt; 引用插件（require）--&gt; 使用插件（通常为new一个示例，添加到plugins数组中）</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">    const path = require(&apos;path&apos;)</span><br><span class="line">    //引入插件 html-webpack-plugin</span><br><span class="line">    const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">    module.exports = &#123;</span><br><span class="line">        entry: &apos;./src/index.js&apos;,</span><br><span class="line">        output: &#123;</span><br><span class="line">            filename: &apos;built.js&apos;,</span><br><span class="line">            path: path.resolve(__dirname,&apos;build&apos;)</span><br><span class="line">        &#125;,</span><br><span class="line">        module:&#123;</span><br><span class="line">            rules: [</span><br><span class="line">                &#123;</span><br><span class="line">                    test: /\.css$/,</span><br><span class="line">                    use:[&apos;style-loader&apos;,&apos;css-loader&apos;]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new HtmlWebpackPlugin(&#123;</span><br><span class="line">                template: &apos;./src/index.html&apos;</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模式 mode</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mode 参数 可选值为 development 或 production，webpack会根据相应的模式进行内置优化</span><br><span class="line"></span><br><span class="line">development: 开发模式，代码不会压缩</span><br><span class="line">productionL: 生产模式，webpack自动压缩代码</span><br></pre></td></tr></table></figure>

<h4 id="以上全部简单示例"><a href="#以上全部简单示例" class="headerlink" title="以上全部简单示例"></a>以上全部简单示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">   //引入插件 html-webpack-plugin</span><br><span class="line">   const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">   module.exports = &#123;</span><br><span class="line">       entry: &apos;./src/index.js&apos;,</span><br><span class="line">       output: &#123;</span><br><span class="line">           filename: &apos;built.js&apos;,</span><br><span class="line">           path: path.resolve(__dirname,&apos;build&apos;)</span><br><span class="line">       &#125;,</span><br><span class="line">       mode: &apos;development&apos;,</span><br><span class="line">       module:&#123;</span><br><span class="line">           rules: [</span><br><span class="line">               &#123;</span><br><span class="line">                   test: /\.css$/,</span><br><span class="line">                   use:[&apos;style-loader&apos;,&apos;css-loader&apos;]</span><br><span class="line">               &#125;</span><br><span class="line">           ]</span><br><span class="line">       &#125;,</span><br><span class="line">       plugins: [</span><br><span class="line">           new HtmlWebpackPlugin(&#123;</span><br><span class="line">               template: &apos;./src/index.html&apos;</span><br><span class="line">           &#125;)</span><br><span class="line">       ]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS实现自适应正方形</title>
    <url>/2020/03/25/CSS%E5%AE%9E%E7%8E%B0%E8%87%AA%E9%80%82%E5%BA%94%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>vw单位实现<br>什么是vw、vh、vmin、vmax?<br>先了解一下视口的概念。 在PC端，视口是值浏览器的可视区域；在移动端，则涉及3个视口：Layout Viewport(布局视口)、Visual Viewport(视觉视口)、Idea Viewport(理想视口)。<br>常说的视口，在PC端指的是 浏览器的可视区域；移动端指的是 layout viewport，浏览器内部的可视区域的大小。即 window.innerWidth/window.innerHeight大小，不包含任务标题栏和底部工具栏的浏览器区域大小。</p><a id="more"></a>
<p>在CSS规范中，视口单位有以下4种：</p>
<p>1.vw: 1vw等于视口宽度的1%<br>2.vh: 1vh等于视口高度的1%<br>3.vmin: 选取vw和vh中最小的那个<br>4.vmax: 选取vw和vh中最大的那个</p>
<p>第一种：宽度百分之五十，高度为50vw</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">  width:50%;</span><br><span class="line">  height:50vw;</span><br><span class="line">  background:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种: paddig-top或padding-bottom来实现，marging和padding的单位都是相对于宽度</p>
<p>padding-top实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">  width:50%;</span><br><span class="line">  height:0;</span><br><span class="line">  padding-top: 50%;</span><br><span class="line">  background:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>padding-bottom实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">  width:50%;</span><br><span class="line">  height:0;</span><br><span class="line">  padding-bttom: 50%;</span><br><span class="line">  background:pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>判断一个字符串中出现次数最多的字符并统计次数</title>
    <url>/2020/03/25/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B9%B6%E7%BB%9F%E8%AE%A1%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>eg； str = ‘abcdeffffgenbggoo’</p><a id="more"></a>
<p>将字符串转为数组arr，然后利用对象属性，遍历数组arr，将数组arr[i]中的值设为对象obj的属性，并给该属性初始值设为1，没出现一次，对应的属性值加1，这样属性值对应的就是该元素出现的次数了。若对象中，无 arr[i] 属性，则obj添加arr[i] 属性，遍历完成后得到保存 转化后的以数组的 值为对象的key, 出现的次数为 value的 一个obj对象。<br>然后，遍历得到的obj对象，比较每一key对应的value值，当value值最大时，则对应的key即为出现次数最多的字符，value即为出现的次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str = &apos;abcdeffffgenbfggoo&apos;</span><br><span class="line">function getMaxNumStr (str)&#123;</span><br><span class="line">  let obj = getObj(str)</span><br><span class="line"> </span><br><span class="line">  let strNumber=0,  //最多字符出现的次数</span><br><span class="line">  strItem = &apos;&apos; //出现次数最多的字符</span><br><span class="line">  //遍历obj</span><br><span class="line">  for( let key in obj)&#123;</span><br><span class="line">    if(obj[key]&gt;strNumber)&#123;</span><br><span class="line">      strNumber = obj[key]</span><br><span class="line">      strItem = key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`字符$&#123;strItem&#125;出现次数最多的,出现次数为$&#123;strNumber&#125;次`)</span><br><span class="line">&#125;</span><br><span class="line">//获取数组值对象</span><br><span class="line">function getObj (str)&#123;</span><br><span class="line">  let arr = str.split(&apos;&apos;)</span><br><span class="line">  let json =&#123;&#125;</span><br><span class="line">  for(let i =0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(!json[arr[i]])&#123;</span><br><span class="line">      json[arr[i]] =1</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      json[arr[i]]+=1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return json</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMaxNumStr(str) //字符f出现次数最多的,出现次数为5次</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数组去重</title>
    <url>/2020/03/25/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="set去重"><a href="#set去重" class="headerlink" title="set去重"></a>set去重</h3><p>利用ES6新增数据类型，其特点是接收一个数组或类数组对象，作为参数来初始化数据，且数据不能重复</p><a id="more"></a>
<p>1.与数组的结构赋值搭配去重</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function newArr ( arr ) &#123;</span><br><span class="line">  return [...new Set(arr)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.与Array.form 搭配去重</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function newArr (arr) &#123;</span><br><span class="line">  let newAarray = new Set(arr)</span><br><span class="line">  return Array.form(newArray)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="indexOf-去重"><a href="#indexOf-去重" class="headerlink" title="indexOf()去重"></a>indexOf()去重</h3><p>最常见的去重方式：先定义一个空数组，然后调用indexOf方法对原来的数组进行遍历，若 indexOf[arr[i]]返回 -1 则把 arr[i] 放入空数组中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function newArr ( arr ) &#123;</span><br><span class="line">  let newArray = []</span><br><span class="line">  for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(newArray.indexOf(arr[i]) === -1)&#123;</span><br><span class="line">      newArray.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象属性去重"><a href="#对象属性去重" class="headerlink" title="对象属性去重"></a>对象属性去重</h3><p>创建一个空对象obj和一个空数组newArray，遍历数组arr，将数组arr[i]中的值设为对象obj的属性，并给该属性初始值设为1，没出现一次，对应的属性值加1，这样属性值对应的就是该元素出现的次数了。若对象中，无 arr[i] 属性，则push到创建的空数组newArray中，同时obj添加arr[i] 属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function newArr (arr)&#123;</span><br><span class="line">  let obj=&#123;&#125;,newArray=[]</span><br><span class="line">  for (let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(!obj[arr[i]])&#123;</span><br><span class="line">      newArray.push(arr[i])</span><br><span class="line">      obj[arr[i]] = 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      obj[arr[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序后-相邻去重"><a href="#排序后-相邻去重" class="headerlink" title="排序后,相邻去重"></a>排序后,相邻去重</h3><p>先调用 sort 方法，然后遍历数组，若当前元素与下一个元素相同，则说明重复，不相同则添加到新数组中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function newArr (arr)&#123;</span><br><span class="line">  let newArray =[]</span><br><span class="line">  arr = arr.sort()</span><br><span class="line">  newArray = [arr[0]]</span><br><span class="line">  for(let i =1;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(arr[i] !== arr[i-1])&#123;</span><br><span class="line">      newArray.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双重循环去重-（方法一）"><a href="#双重循环去重-（方法一）" class="headerlink" title="双重循环去重 （方法一）"></a>双重循环去重 （方法一）</h3><p>获取没重复的最右边的值放入新数组，检测到有重复值时终止当前循环同时，进入顶层的循环进行下一轮判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function newArr (arr) &#123;</span><br><span class="line">  let newArray =[]</span><br><span class="line">  for(let i =0; i&lt; arr.length;i++)&#123;</span><br><span class="line">    for(let j = i+1; j&lt; arr.length;j++)&#123;</span><br><span class="line">      if(arr[i] === arr[j])&#123;</span><br><span class="line">        i++;</span><br><span class="line">        j = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newArray.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(index)</span><br><span class="line">  return newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双重循环去重-（方法二）"><a href="#双重循环去重-（方法二）" class="headerlink" title="双重循环去重 （方法二）"></a>双重循环去重 （方法二）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function newArr2(arr) &#123;</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    for (let j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">      if (arr[i] == arr[j]) &#123;</span><br><span class="line">        arr.splice(j, 1)</span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数组排序</title>
    <url>/2020/03/25/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.sort((a,b) =&gt; &#123;</span><br><span class="line">  //return a-b  //升序</span><br><span class="line">  return b-a    //降序</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>相邻的两个数进行比较，每一轮比较后，最大（小）的数在最后<br>N个数字的数组排序，总共进行N-1次排序，每趟的排序次数为 N-i次，使用双重循环，外层控制循环次数，内层每趟的比较次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [10,8,5,2,3,6]</span><br><span class="line"></span><br><span class="line">for(let i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">  for(let j =0;j&lt; arr.length-1-i;j++)&#123;</span><br><span class="line">    if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">      let temp = arr[j]</span><br><span class="line">      arr[j] =arr[j+1]</span><br><span class="line">      arr[j+1] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr) // [2,3,5,6,8,10]</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [12,20,50,26,32,68]</span><br><span class="line"></span><br><span class="line">for(let i= 0; i&lt;arr.length-1;i++)&#123;</span><br><span class="line">  for(let j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">    if(arr[i]&gt;arr[j])&#123;</span><br><span class="line">      let temp = arr[i]</span><br><span class="line">      arr[i] = arr[j]</span><br><span class="line">      arr[j] = temp</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr) //[12, 20, 26, 32, 50, 68]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>根据路径从嵌套的js对象中取值</title>
    <url>/2020/03/14/%E6%A0%B9%E6%8D%AE%E8%B7%AF%E5%BE%84%E4%BB%8E%E5%B5%8C%E5%A5%97%E7%9A%84js%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%8F%96%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>根据一个路径从嵌套的js对象中取出值，如果路径不存在则返回null，路径类型为字符串数组</p><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">  path = [&apos;a&apos;,&apos;b&apos;] //路径</span><br><span class="line">  obj = &#123; a: &#123; b:2 &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>思考: 用字符串数组中的value值,作为的key,并取对象的key的值，如果有值则说明路径值存在。此时需继续取数组中的value值，作为key去匹配上一个value匹配到的对象值，即要递归调用。既然是递归，那么问题来了，递归必须要有一个终止条件，否则会造成栈溢出。这时当取到字符串最后一个值时，如果匹配到值，则为对应的值，如果没有匹配到值则返回null,此时所取的字符串数组为最后一个值时就是终止递归的条件。</p>
<p>coding :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let path = [&apos;a&apos;,&apos;b&apos;]</span><br><span class="line">let obj = &#123; a: &#123; b:2 &#125;&#125;</span><br><span class="line"></span><br><span class="line">function getDeep ( arr,obj ) &#123;</span><br><span class="line">  let strArr = arr.slice(1) </span><br><span class="line">  let subObj = obj[path[0]]</span><br><span class="line">  if ( arr.length&gt;1 &amp;&amp; obj[arr[0]] ) &#123;</span><br><span class="line">    getDeep ( strArr,subObj )</span><br><span class="line">  &#125; else if (arr.length === 1) &#123;</span><br><span class="line">    console.log(&apos;匹配到的路径值&apos;, subObj == undefined ? &apos;null&apos; : subObj)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getDeep ( path, obj ) // 匹配到的路径值:2</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在小程序中使用fontAwesome</title>
    <url>/2020/03/08/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8fontAwesome/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前在写小程序时，遇到的字体图标引用的问题，在此记录一下。</p><a id="more"></a>
<h3 id="原生小程序中使用方法："><a href="#原生小程序中使用方法：" class="headerlink" title="原生小程序中使用方法："></a>原生小程序中使用方法：</h3><p>第一步：官网下载font awesome 下载字体图标压缩包，注意版本为V4.7以下。<br>1.1 fontAwesome官网地址:<a href="http://www.fontawesome.com.cn/" target="_blank" rel="noopener">http://www.fontawesome.com.cn/</a></p>
<p>第二步：将fontAwesome字体实体转为base64编码文件<br>2.1 解压下载的压缩包找到fontawesome-webfont.ttf文件。<br>压缩包解压–&gt;fonts–&gt;fontawesome-webfont.ttf<br><img src="/images/ft-ttf.png" alt></p>
<p>2.2 将fontawesome-webfont.ttf文件转为base64编码<br>打开 <a href="https://transfonter.org/" target="_blank" rel="noopener">转码网址</a>,可在线进行转码。<br><img src="/images/ft-upload.png" alt></p>
<p>下载转码后的压缩包文件<br><img src="/images/base-success.png" alt></p>
<p>2.3解压转码后的压缩包，打开style.css文件<br><img src="/images/base-stylecss.jpg" alt><br><img src="/images/style-css.jpg" alt></p>
<p>第三步：获取编码后的最新的font-awesome<br>3.1 打开步骤一中，下载的字体压缩包，找到font-awesome.css文件<br>步骤一下载的压缩包–&gt; css –&gt; font-awesome.css</p>
<p>3.2 打开 font-awesome.css，删除文件中中 @font-face 及其内容。<br><img src="/images/delete.jpg" alt></p>
<p>3.3 将2.3中的style.css文件中的内容复制到3.2中，删除@font-face后的的font-awesome.css内容的最上方。</p>
<p>3.4 此时的font-awesome.css便是我们要在小程序中引用的fontAwesome的样式文件。</p>
<p>第四步：在原生小程序中引用font-awesome.css<br>为方便起见，这里全局引入。在小程序的app.wxss中直接引入： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//(xx为你的文件路径)</span><br><span class="line">@import &quot;/xx/font-awesome.wxss&quot;</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;text class=&quot;fa fa-star-o&quot;&gt;&lt;/text&gt;</span><br></pre></td></tr></table></figure>

<h3 id="mpvue中使用fontAwesome"><a href="#mpvue中使用fontAwesome" class="headerlink" title="mpvue中使用fontAwesome"></a>mpvue中使用fontAwesome</h3><p>mpvue支持模块化下载，直接安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install font-awesome</span><br></pre></td></tr></table></figure>

<p>然后在主应用的main.js中全局引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;font-awesome/css/font-awesome.min.css&apos;;</span><br></pre></td></tr></table></figure>

<p>应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span class=&quot;fa fa-eye&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>这样就可以在组件中愉快的使用想要的字体图标了。</p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>vue+ts中给Vue拓展属性</title>
    <url>/2019/12/23/vue-ts%E4%B8%AD%E7%BB%99Vue%E6%8B%93%E5%B1%95%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在vue+ts项目中通过prototype给Vue拓展属性时，发现拓展的属性无法获取到，查<a href="'https://vuejs.bootcss.com/v2/guide/typescript.html#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84-Vue-%E7%BB%84%E4%BB%B6'">文档</a>后发现需要进行类型声明.</p><a id="more"></a>
<p>解决方案如下：</p>
<p>在src/目录下新建一个 .d.ts 文件,如：my-property.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1. 确保在声明补充的类型之前导入 &apos;vue&apos;</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">// 2. 定制一个文件，设置你想要补充的类型</span><br><span class="line">//    在 types/vue.d.ts 里 Vue 有构造函数类型</span><br><span class="line">declare module &apos;vue/types/vue&apos; &#123;</span><br><span class="line">// 3. 声明为 Vue 补充的东西</span><br><span class="line">  interface Vue &#123;</span><br><span class="line">    $myMgr: string</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若还是报错，重启编辑器即可。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli3.0 配置postcss-px2rem</title>
    <url>/2019/12/09/use-postcss-px2rem/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem相对于根html,em相对于父级<br>现在常用的适配rem的方法：<br>方法一：<br>1、获取页面宽度</p><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let deviceWith = document.documentElement.getBoundingClientRect().width</span><br></pre></td></tr></table></figure>
<p>2.设置根html的font-size</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//100为参照，之所以取一个100作为参照，是为了计算rem方便</span><br><span class="line">document.documentElement.style.fontSize = deviceWith /&apos;设计稿的宽度&apos; /100 + &apos;px&apos;;</span><br></pre></td></tr></table></figure>
<p>3.配合媒体查询使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media screen and (max-width:321px)&#123;</span><br><span class="line">    .m-navlist&#123;font-size:15px&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width:321px) and (max-width:400px)&#123;</span><br><span class="line">    .m-navlist&#123;font-size:16px&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width:400px)&#123;</span><br><span class="line">    .m-navlist&#123;font-size:18px&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：<br>1.设置html的font-size为62.5%,这样1rem就等于10px,方便计算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">  font-size:62.5%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.重置样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*reset css*/</span><br><span class="line">body,dl,dd,ul,ol,h1,h2,h3,h4,h5,h6,pre,form,input,textarea,p,hr,thead,tbody,tfoot,th,td&#123;margin:0;padding:0;&#125;</span><br><span class="line">ul,ol&#123;list-style:none;&#125;</span><br><span class="line">a&#123;text-decoration:none;&#125;</span><br><span class="line">html&#123;-ms-text-size-adjust:none;-webkit-text-size-adjust:none;text-size-adjust:none;font-size:50px;&#125;</span><br><span class="line">body&#123;line-height:1.5;font-size:16px;&#125;</span><br><span class="line">body,button,input,select,textarea&#123;font-family:&apos;helvetica neue&apos;,tahoma,&apos;hiragino sans gb&apos;,stheiti,&apos;wenquanyi micro hei&apos;,5FAE8F6F96C59ED1,5B8B4F53,sans-serif;&#125;</span><br><span class="line">b,strong&#123;font-weight:bold;&#125;</span><br><span class="line">i,em&#123;font-style:normal;&#125;</span><br><span class="line">table&#123;border-collapse:collapse;border-spacing:0;&#125;</span><br><span class="line">table th,table td&#123;border:1px solid #ddd;padding:5px;&#125;</span><br><span class="line">table th&#123;font-weight:inherit;border-bottom-width:2px;border-bottom-color:#ccc;&#125;</span><br><span class="line">img&#123;border:0 none;width:auto;max-width:100%;vertical-align:top;&#125;</span><br><span class="line">button,input,select,textarea&#123;font-family:inherit;font-size:100%;margin:0;vertical-align:baseline;&#125;</span><br><span class="line">button,html input[type=&quot;button&quot;],input[type=&quot;reset&quot;],input[type=&quot;submit&quot;]&#123;-webkit-appearance:button;cursor:pointer;&#125;</span><br><span class="line">button[disabled],input[disabled]&#123;cursor:default;&#125;</span><br><span class="line">input[type=&quot;checkbox&quot;],input[type=&quot;radio&quot;]&#123;box-sizing:border-box;padding:0;&#125;</span><br><span class="line">input[type=&quot;search&quot;]&#123;-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box;&#125;</span><br><span class="line">input[type=&quot;search&quot;]::-webkit-search-decoration&#123;-webkit-appearance:none;&#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio:0)&#123;</span><br><span class="line">    input&#123;line-height:normal!important;&#125;</span><br><span class="line">&#125;</span><br><span class="line">select[size],select[multiple],select[size][multiple]&#123;border:1px solid #AAA;padding:0;&#125;</span><br><span class="line">article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary&#123;display:block;&#125;</span><br><span class="line">audio,canvas,video,progress&#123;display:inline-block;&#125;</span><br></pre></td></tr></table></figure>

<p>淘宝rem适配方案：<br>1.动态设置viewport的scale</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var scale = 1 / devicePixelRatio;</span><br><span class="line">document.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;).setAttribute(&apos;content&apos;,&apos;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;);</span><br></pre></td></tr></table></figure>

<p>2.动态计算html的font-size</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + &apos;px&apos;;</span><br></pre></td></tr></table></figure>
<p>3.布局的时候，各元素的css尺寸=设计稿标注尺寸/设计稿横向分辨率/10<br>4.font-size可能需要额外的媒介查询，并且font-size不使用rem</p>
<h4 id="使用第三方插件-postcss-px2rem"><a href="#使用第三方插件-postcss-px2rem" class="headerlink" title="使用第三方插件 postcss-px2rem"></a>使用第三方插件 postcss-px2rem</h4><h5 id="安装postcss-px2rem"><a href="#安装postcss-px2rem" class="headerlink" title="安装postcss-px2rem"></a>安装postcss-px2rem</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install postcss-px2rem --save</span><br></pre></td></tr></table></figure>
<h5 id="vue-congfig-js-中配置"><a href="#vue-congfig-js-中配置" class="headerlink" title="vue.congfig.js 中配置"></a>vue.congfig.js 中配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const px2rem = require(&apos;postcss-px2rem&apos;)</span><br><span class="line">const postcss = px2rem(&#123;</span><br><span class="line">  remUnit: 100,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      postcss: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">          postcss,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Next配置live2d 看板娘</title>
    <url>/2019/12/01/use-live2d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="使用Next内置的live2d（基础版）"><a href="#使用Next内置的live2d（基础版）" class="headerlink" title="使用Next内置的live2d（基础版）"></a>使用Next内置的live2d（基础版）</h4><a id="more"></a><h5 id="安装live2d模块"><a href="#安装live2d模块" class="headerlink" title="安装live2d模块"></a>安装live2d模块</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
<h5 id="站点配置文件-config-yml-中新增："><a href="#站点配置文件-config-yml-中新增：" class="headerlink" title="站点配置文件_config.yml 中新增："></a>站点配置文件_config.yml 中新增：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br><span class="line">  react:</span><br><span class="line">    opacity: 0.7</span><br></pre></td></tr></table></figure>
<p>配置完以上步骤，清缓存，重新启动项目，刷新页面就可以看到博客右下角有个萌萌的站宠了。</p>
<h5 id="更换live2d模型"><a href="#更换live2d模型" class="headerlink" title="更换live2d模型"></a>更换live2d模型</h5><h6 id="安装模型对应的包名packagename"><a href="#安装模型对应的包名packagename" class="headerlink" title="安装模型对应的包名packagename"></a>安装模型对应的包名packagename</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-packagename  //packagename是要安装的包名</span><br></pre></td></tr></table></figure>
<p>效果参考：<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">模型效果</a><br>全部包名用法：<a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">npm 模块名</a></p>
<h6 id="使用新模型"><a href="#使用新模型" class="headerlink" title="使用新模型"></a>使用新模型</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">model:</span><br><span class="line">    use: live2d-widget-model-packagename  #packagename改为新安装的模块名即可</span><br></pre></td></tr></table></figure>

<h4 id="高级版"><a href="#高级版" class="headerlink" title="高级版"></a>高级版</h4><p>具有换装、对话、换人等功能。<br>下载大神定制的作品：<a href="https://github.com/stevenjoezhang/live2d-widget">传送门</a><br>下载后解压并重新命名到 \themes\next\source 文件夹下，修改解压后文件中的 autoload.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const live2d_path = &quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/&quot;;</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const live2d_path = &quot;/重新命名的文件名/&quot;;</span><br></pre></td></tr></table></figure>
<p>在/themes/next/layout/_layout.swing中,body标签中新增如下内容，将yourName修改为自己的github账号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://yourName.github.io/live2d/autoload.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>head标签中新增依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>在主题配置文件_config.yml 中,添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<p>执行命令三连：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo c </span><br><span class="line">hexo g </span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>至此一个萌萌的站板娘就生成了。<br><img src="/images/live2d.png" alt></p>
<p>还可根据需要自行修改：<br>waifu.css修改看板的大小和位置，waifu-tips.json修改对话</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.jianshu.com/p/dba9a729fa57" target="_blank" rel="noopener">在hexo+next博客添加一个live2d看板娘</a><br><a href="https://blog.csdn.net/qq_39610915/article/details/90679768" target="_blank" rel="noopener">Hexo博客优化：在Next主题中设置进阶版Live2D看板娘</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Next 使用 valine 评论模块</title>
    <url>/2019/11/28/use-valine/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="注册LeanCloude账号"><a href="#注册LeanCloude账号" class="headerlink" title="注册LeanCloude账号"></a>注册LeanCloude账号</h3><a id="more"></a><p>官网传送门： <a href="https://leancloud.cn" target="_blank" rel="noopener">LeanCloude</a></p>
<h3 id="LeanCloude配置"><a href="#LeanCloude配置" class="headerlink" title="LeanCloude配置"></a>LeanCloude配置</h3><h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><p>点击创建应用<br><img src="/images/step1.png" alt><br>自己取一个应用名<br><img src="/images/step2.png" alt></p>
<h4 id="创建一个类"><a href="#创建一个类" class="headerlink" title="创建一个类"></a>创建一个类</h4><p>前面应用已经创建完毕，需要创建一个类Comment来存放评论信息。<br>在 LeanCloud -&gt; 存储 -&gt; 创建Class -&gt; 无限制的Class，class 名称为：Comment。<br><img src="/images/step3.png" alt></p>
<h4 id="安全设置"><a href="#安全设置" class="headerlink" title="安全设置"></a>安全设置</h4><p>在 leancloude -&gt; 设置 -&gt; 安全中心，把除数据存储外其他选项都关闭</p>
<h3 id="Next中配置valine"><a href="#Next中配置valine" class="headerlink" title="Next中配置valine"></a>Next中配置valine</h3><p>在leancloude -&gt; 设置 -&gt; 应用keys -&gt; 获得 appkey、appid<br>进入主题配置中，找到 <span style="color:red">valine</span>，配置appkey、appid</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version</span><br><span class="line">  appid:  # Your leancloud application appid</span><br><span class="line">  appkey: # Your leancloud application appkey</span><br><span class="line">  notify: false # Mail notifier. See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: &apos;ヾﾉ≧∀≦)o来啊，快活啊!&apos; # Comment box placeholder</span><br><span class="line">  avatar: mm # Gravatar style</span><br><span class="line">  guest_info: nick,mail,link # Custom comment header</span><br><span class="line">  pageSize: 10 # Pagination size</span><br></pre></td></tr></table></figure>
<h3 id="配置CDN"><a href="#配置CDN" class="headerlink" title="配置CDN"></a>配置CDN</h3><p>进入主题配置文件，配置成第三方 CDN</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Valine</span><br><span class="line"> # valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js</span><br><span class="line"> # valine: //cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js</span><br><span class="line"> valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js</span><br></pre></td></tr></table></figure>

<h3 id="指定文章是否开启评论功能"><a href="#指定文章是否开启评论功能" class="headerlink" title="指定文章是否开启评论功能"></a>指定文章是否开启评论功能</h3><p>hexo评论的功能是在所有页面都默认开启的，但是有的时候我们在页面上不需要显示评论功能，例如分类，标记页面。<br>在Front-matter中设置comments: false即可关闭。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2019-11-28</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://tding.top/archives/ed8b904f.html" target="_blank" rel="noopener">https://tding.top/archives/ed8b904f.html</a><br><a href="https://blog.csdn.net/jiunian_2761/article/details/97388997" target="_blank" rel="noopener">https://blog.csdn.net/jiunian_2761/article/details/97388997</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo主题配置Next</title>
    <url>/2019/11/27/hexo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="next开启文章版权板块"><a href="#next开启文章版权板块" class="headerlink" title="next开启文章版权板块"></a>next开启文章版权板块</h3><a id="more"></a><p>1.早期版本<br><a href="https://blog.pangao.vip/Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E/" target="_blank" rel="noopener">教程</a></p>
<p>2.新版本，本文版本为 7.0.5为例<br>将主题配置中的post改为true，然后 hexo clean, hexo s 刷新文章页面即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: true</span><br><span class="line">  post: true</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>git从远程仓库获取最新代码合并到本地分支</title>
    <url>/2019/11/27/usegit/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这里共展示两类三种方式。</p><a id="more"></a>
<h3 id="1-git-pull：获取最新代码到本地，并自动合并到当前分支"><a href="#1-git-pull：获取最新代码到本地，并自动合并到当前分支" class="headerlink" title="1.git pull：获取最新代码到本地，并自动合并到当前分支"></a>1.git pull：获取最新代码到本地，并自动合并到当前分支</h3><p>命令展示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//查询当前远程的版本</span><br><span class="line">$ git remote -v </span><br><span class="line">//直接拉取并合并最新代码</span><br><span class="line">$ git pull origin master [示例1：拉取远端origin/master分支并合并到当前分支]</span><br><span class="line">$ git pull origin dev [示例2：拉取远端origin/dev分支并合并到当前分支]</span><br></pre></td></tr></table></figure>
<p style="color:red">分析：不推荐这种方式，因为是直接合并，无法提前处理冲突。</p>

<h3 id="2-git-fetch-merge-获取最新代码到本地，然后手动合并分支"><a href="#2-git-fetch-merge-获取最新代码到本地，然后手动合并分支" class="headerlink" title="2.git fetch + merge: 获取最新代码到本地，然后手动合并分支"></a>2.git fetch + merge: 获取最新代码到本地，然后手动合并分支</h3><h4 id="2-1-额外建立本地分支"><a href="#2-1-额外建立本地分支" class="headerlink" title="2.1.额外建立本地分支"></a>2.1.额外建立本地分支</h4><p>代码展示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//查看当前远程的版本</span><br><span class="line">$ git remote -v </span><br><span class="line">//获取最新代码到本地临时分支(本地当前分支为[branch]，获取的远端的分支为[origin/branch])</span><br><span class="line">$ git fetch origin master:master1  [示例1：在本地建立master1分支，并下载远端的origin/master分支到master1分支中]</span><br><span class="line">$ git fetch origin dev:dev1[示例1：在本地建立dev1分支，并下载远端的origin/dev分支到dev1分支中]</span><br><span class="line">//查看版本差异</span><br><span class="line">$ git diff master1 [示例1：查看本地master1分支与当前分支的版本差异]</span><br><span class="line">$ git diff dev1    [示例2：查看本地dev1分支与当前分支的版本差异]</span><br><span class="line">//合并最新分支到本地分支</span><br><span class="line">$ git merge master1    [示例1：合并本地分支master1到当前分支]</span><br><span class="line">$ git merge dev1   [示例2：合并本地分支dev1到当前分支]</span><br><span class="line">//删除本地临时分支</span><br><span class="line">$ git branch -D master1    [示例1：删除本地分支master1]</span><br><span class="line">$ git branch -D dev1 [示例1：删除本地分支dev1]</span><br></pre></td></tr></table></figure>
<p style="color:red">备注：不推荐这种方式，还需要额外对临时分支进行处理。</p>

<h3 id="2-2-不额外建立本地分支"><a href="#2-2-不额外建立本地分支" class="headerlink" title="2.2 不额外建立本地分支"></a>2.2 不额外建立本地分支</h3><p>代码展示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//查询当前远程的版本</span><br><span class="line">$ git remote -v</span><br><span class="line">//获取最新代码到本地(本地当前分支为[branch]，获取的远端的分支为[origin/branch])</span><br><span class="line">$ git fetch origin master  [示例1：获取远端的origin/master分支]</span><br><span class="line">$ git fetch origin dev [示例2：获取远端的origin/dev分支]</span><br><span class="line">//查看版本差异</span><br><span class="line">$ git log -p master..origin/master [示例1：查看本地master与远端origin/master的版本差异]</span><br><span class="line">$ git log -p dev..origin/dev   [示例2：查看本地dev与远端origin/dev的版本差异]</span><br><span class="line">//合并最新代码到本地分支</span><br><span class="line">$ git merge origin/master  [示例1：合并远端分支origin/master到当前分支]</span><br><span class="line">$ git merge origin/dev [示例2：合并远端分支origin/dev到当前分支]</span><br></pre></td></tr></table></figure>
<p style="color:red">备注：推荐这种方式。</p>

<h3 id="原文链接：https-blog-csdn-net-hanchao5272-article-details-79162130"><a href="#原文链接：https-blog-csdn-net-hanchao5272-article-details-79162130" class="headerlink" title="原文链接：https://blog.csdn.net/hanchao5272/article/details/79162130"></a>原文链接：<a href="https://blog.csdn.net/hanchao5272/article/details/79162130" target="_blank" rel="noopener">https://blog.csdn.net/hanchao5272/article/details/79162130</a></h3><h3 id="git-本地创建远程分支"><a href="#git-本地创建远程分支" class="headerlink" title="git 本地创建远程分支"></a>git 本地创建远程分支</h3><p>$ git branch<br>    * master<br>      release</p>
<p>新建远程分支</p>
<p>新建一个本地分支：</p>
<pre><code>$ git checkout -b dbg_lichen_star</code></pre><p>查看一下现在的分支状态:</p>
<pre><code>$ git branch
* dbg_lichen_star
  master
  release</code></pre><p>星号(*)表示当前所在分支。现在的状态是成功创建的新的分支并且已经切换到新分支上。</p>
<p>把新建的本地分支push到远程服务器，远程分支与本地分支同名（当然可以随意起名）：</p>
<pre><code>$ git push origin dbg_lichen_star:dbg_lichen_star</code></pre><p>使用git branch -a查看所有分支，会看到remotes/origin/dbg_lichen_star这个远程分支，说明新建远程分支成功。<br>删除远程分支</p>
<p>我比较喜欢的简单方式，推送一个空分支到远程分支，其实就相当于删除远程分支：</p>
<pre><code>$ git push origin :dbg_lichen_star</code></pre><p>也可以使用：</p>
<pre><code>$ git push origin --delete dbg_lichen_star</code></pre><p>这两种方式都可以删除指定的远程分支</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><span style="color:red"><a href="https://blog.csdn.net/hanchao5272/article/details/79162130" target="_blank" rel="noopener">https://blog.csdn.net/hanchao5272/article/details/79162130</a></span></p>
]]></content>
      <categories>
        <category>版本控制工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
